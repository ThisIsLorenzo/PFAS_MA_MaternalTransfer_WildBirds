---
title: "Code"
author: "LR"
date: '2022-06-28'
output: html_document
editor_options: 
  chunk_output_type: inline
---
# Porpuse: This .Rmd document provides the code we used for data processing and data visualization.

## Data processing workflow.

We use a dm object to create a relational data model from our local data tables.
The six tables that we are working with contain data extracted from the
included studies. The six tables are named as follow: **study_info**, **species_info**, **pfas_info**,
**cohort_info**, **sample_info**, **measurements**.

```{r loading packages, message = FALSE, echo = TRUE, eval = TRUE, warning = FALSE}
library(tidyverse)
library(readr)
library(ape, curl)
library(rotl)
library(here)
library(dm)
library(dplyr)
library(metafor)
```

```{r loading data, include=FALSE}
st <- read_csv(here("Data", "study_info.csv"))
sp <- read_csv(here("Data", "species_info.csv"))
pfas <- read_csv(here("Data", "pfas_info.csv"))
co <- read_csv(here("Data", "cohort_info.csv"))
sa <- read_csv(here("Data", "sample_info.csv"))
me <- read_csv(here("Data", "measurement_info.csv"))
```

```{r cleaning - removing unnecessary columns (i.e., "Timestamp" and comment columns)}
st <- st %>% 
  select(-("Timestamp")) %>%
  select(-(ends_with("comment")))
sp <- sp %>% 
  select(-("Timestamp")) %>%
  select(-(ends_with("comment")))
pfas <- pfas %>% 
  select(-("Timestamp")) %>% 
  select(-(ends_with("comment")))
co <- co %>% 
  select(-("Timestamp")) %>%
  select(-(ends_with("comment")))
sa <- sa %>% 
  select(-("Timestamp")) %>% 
  select(-(ends_with("comment")))
me <- me %>%
  select(-(ends_with("comment")))
```

### dm object - relational database

```{r adding tables to the dm object, include=FALSE}
data_dm_no_keys <- dm(st, sp, pfas, co, sa, me)
data_dm_no_keys
data_dm_no_keys$st
data_dm_no_keys[c("st", "co")]
```

```{r defining primary keys}
data_dm_only_pks <- data_dm_no_keys %>% 
  dm_add_pk(table = st, columns = study_ID) %>% 
  dm_add_pk(sp, species_ID) %>% 
  dm_add_pk(pfas, pfas_ID) %>% 
  dm_add_pk(co, cohort_ID) %>% 
  dm_add_pk(sa, sample_ID) %>% 
  dm_add_pk(me, measurement_ID)
data_dm_only_pks
```

```{r defining foreign keys}
data_dm_all_keys <- 
  data_dm_only_pks %>% 
  dm_add_fk(table = co, columns = study_ID, ref_table = st) %>% 
  dm_add_fk(table = co, columns = species_ID, ref_table = sp) %>%
  dm_add_fk(table = sa, columns = cohort_ID, ref_table = co) %>%
  dm_add_fk(table = me, columns = sample_ID, ref_table = sa) %>%
  dm_add_fk(table = me, columns = pfas_ID, ref_table = pfas)
data_dm_all_keys
```
```{r visualization}
data_dm_all_keys %>% 
  dm_draw()
```
```{r integrity check}
data_dm_all_keys %>% 
  dm_examine_constraints()
```

```{r merging all tables into one big table}
dm_joined <- 
  data_dm_all_keys %>% 
  dm_flatten_to_tbl(.start = me, .recursive = TRUE)
dm_joined
```



The following chunk creates a new table that includes only the variables we need to calculate effect sizes
```{r moving columns among dm objects}
me1 <- 
  data_dm_all_keys %>% 
  dm_select(me, measurement_ID | group_info | sample_ID | pfas_ID | mean_arithmetic | SD | n) %>% 
  dm_select(co, cohort_ID | species_ID | study_ID | sampling_location | life_stage) %>% 
  dm_select(pfas, pfas_ID) %>% 
  dm_select(sp, species_ID) %>% 
  dm_select(st, study_ID) %>% 
  dm_flatten_to_tbl(.start = me, .recursive = TRUE, .join = left_join)

colnames(me1)
```

Now I want to create a new column called "es_ID" which matches all the pairs of measurement I will use in the escalc() function.
Study, PFAS type, species, and sampling location must be the same, so I group by them.
The group (i.e., group_info) must be different

```{r}
#group by

list_dat <- 
  me1 %>% 
  dplyr::group_split(study_ID,
                  pfas_ID , 
                  species_ID,
                  sampling_location)


# TODO 

# tdat <- data.frame(me1[me1$study_ID == "S_003" & me1$pfas_ID == "pfas_001", ])
# 
# 
# adult <- tdat[tdat$group_info == "adult", 1]
# progeny <-tdat[tdat$group_info == "progeny", 1]
# 
# ids <- expand.grid(adult_id = adult, progeny_id = progeny)
# 
# adult_id <- ids[[1]]
# progeny_id <- ids[[2]]
# 
# pos_adult <- match(adult_id, tdat$measurement_ID)
# adult_dat <- tdat[pos_adult, ]
# 
# pos_progeny <- match(progeny_id, tdat$measurement_ID)
# progeny_dat <- tdat[pos_progeny, ]
# 
# #ndat<-as.data.frame(cbind(adult_dat, chick_dat))
# 
# ndat <- data.frame(measurement_ID_A = adult_dat[["measurement_ID"]],
#            measurement_ID_C = progeny_dat[[ "measurement_ID"]],
#            mean_arithmetic_A = adult_dat[["mean_arithmetic"]],
#            mean_arithmetic_C =  progeny_dat[[ "mean_arithmetic"]]
#              )

# head(ndat)

# function

wide_table <- function(dat){

dat <- as.data.frame(dat)  
  
adult <- dat[dat$group_info == "adult", 1]
progeny <-dat[dat$group_info == "progeny", 1]

ids <- expand.grid(adult_id = adult, progeny_id = progeny)

adult_id <- ids[[1]]
progeny_id <- ids[[2]]

pos_adult <- match(adult_id, dat$measurement_ID)
adult_dat <- dat[pos_adult, ]

pos_progeny <- match(progeny_id, dat$measurement_ID)
progeny_dat <- dat[pos_progeny, ]

#ndat<-as.data.frame(cbind(adult_dat, chick_dat))

ndat <- data.frame(measurement_ID_A = adult_dat[["measurement_ID"]],
           measurement_ID_P = progeny_dat[[ "measurement_ID"]],
           mean_arithmetic_A = adult_dat[["mean_arithmetic"]],
           mean_arithmetic_P =  progeny_dat[[ "mean_arithmetic"]],
           SD_A = adult_dat[["SD"]],
           SD_P = progeny_dat[["SD"]],
           n_A = adult_dat[["n"]],
           n_P = progeny_dat[["n"]],
           life_stage_A = adult_dat[["life_stage"]],
           life_stage_P = progeny_dat[["life_stage"]],
           study_ID_A = adult_dat[["study_ID"]],
           study_ID_P = progeny_dat[["study_ID"]],
           species_ID_A = adult_dat[["species_ID"]],
           species_ID_P = progeny_dat[["species_ID"]],
           sample_ID_A = adult_dat[["sample_ID"]],
           sample_ID_P = progeny_dat[["sample_ID"]],
           cohort_ID_A = adult_dat[["cohort_ID"]],
           cohort_ID_P = progeny_dat[["cohort_ID"]],
           sample_type_A = adult_dat[["sample_type"]],
           sample_type_P = progeny_dat[["sample_type"]],
           sampling_location_A = adult_dat[["sampling_location"]],
           sampling_location_P = progeny_dat[["sampling_location"]],
           pfas_ID_A = adult_dat[["pfas_ID"]],
           pfas_ID_P = progeny_dat[["pfas_ID"]]
             )
ndat

}


dat <- list_dat[[3]]

res <- wide_table(list_dat[[3]])
res

# this applies wide_table data to every item in this list
ntable <- map_dfr(list_dat, wide_table)

```


### Create functions
The `lnRR_func` function is here used to calculate a log response ratio (lnRR) adjusted for small sample sizes. In addition, this formula accounts for correlated samples. 
For more details, see *Doncaster and Spake (2018) Correction for bias in meta-analysis of little-replicated studies. Methods in Ecology and Evolution; 9:634-644*

```{r function to calculate effect size}
#Changing columns names to make them shorter
colnames(ntable)[3] <- "mean_A"
colnames(ntable)[4] <- "mean_P"
colnames(ntable)[5] <- "sd_A"
colnames(ntable)[6] <- "sd_P"

# Custom function to calculate the lnRR 
lnRR_func <- function(mean_A, n_A, mean_P, n_P, aCV2a, aCV2p){
  lnRR <- log(mean_P/mean_A) + 
        0.5 * ((aCV2p/n_P) - (aCV2a/n_A))	
  lnRR
}
# Custom function to calculate the lnRR's sampling variance from independent designs (rTC = 0)
var_lnRR_ind <- function(mean_A, n_A, mean_P, n_P, aCV2a, aCV2p){
  
  var_lnRR <- (aCV2a/n_A) + (aCV2p/n_P) 
  
  var_lnRR
}
# Mc: Concentration of PFAS of the raw (control) sample
# Nc: Sample size of the raw (control) sample
# Me: Concentration of PFAS of the cooked (experimental) sample
# Ne: Sample size of the cooked (experimental) sample 
# aCV2c: Mean coefficient of variation of the raw (control) samples
# aCV2e: Mean coefficient of variation of the cooked (experimental) samples

```




## Calculate Effect sizes
``` {r Calculating lnRR and Variance}
aCV2 <- ntable %>% 
               group_by(study_ID_A) %>%  # Group by study 
                    summarise(CV2a = mean((sd_A/mean_A)^2, na.rm = T),  
                              CV2p = mean((sd_P/mean_P)^2, na.rm = T)) %>% 
                              ungroup() %>% # ungroup 
                              summarise(aCV2a = mean(CV2a, na.rm = T), # Mean CV^2 for exp and control groups across studies
                              aCV2p = mean(CV2p, na.rm = T)) 
```
```{r create the forest plot}
#forest(dat2$yi, dat2$vi)
```

