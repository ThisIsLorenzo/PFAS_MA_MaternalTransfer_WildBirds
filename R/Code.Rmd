---
title: "Code"
author: "LR"
date: '2022-06-28'
output: html_document
editor_options: 
  chunk_output_type: inline
---
# Porpuse: This .Rmd document provides the code we used for data processing and data visualization.

## Data processing workflow.

We use a dm object to create a relational data model from our local data tables.
The six tables that we are working with contain data extracted from the
included studies. The six tables are named as follow: **study_info**, **species_info**, **pfas_info**,
**cohort_info**, **sample_info**, **measurements**.

```{r loading packages, message = FALSE, echo = TRUE, eval = TRUE, warning = FALSE}
library(tidyverse)
library(readr)
library(ape, curl)
library(rotl)
library(here)
library(dm)
library(dplyr)
library(metafor)
```

```{r loading data, include=FALSE}
st <- read_csv(here("Data", "study_info.csv"))
sp <- read_csv(here("Data", "species_info.csv"))
pfas <- read_csv(here("Data", "pfas_info.csv"))
co <- read_csv(here("Data", "cohort_info.csv"))
sa <- read_csv(here("Data", "sample_info.csv"))
me <- read_csv(here("Data", "measurement_info.csv"))
```

```{r cleaning - removing unnecessary columns (i.e., "Timestamp" and comment columns)}
st <- st %>% 
  select(-("Timestamp")) %>%
  select(-(ends_with("comment")))
sp <- sp %>% 
  select(-("Timestamp")) %>%
  select(-(ends_with("comment")))
pfas <- pfas %>% 
  select(-("Timestamp")) %>% 
  select(-(ends_with("comment")))
co <- co %>% 
  select(-("Timestamp")) %>%
  select(-(ends_with("comment")))
sa <- sa %>% 
  select(-("Timestamp")) %>% 
  select(-(ends_with("comment")))
me <- me %>%
<<<<<<< HEAD
  #select(-("Timestamp")) %>% 
=======
 # select(-("Timestamp")) %>% 
>>>>>>> ef2660e7b011ffc4fc1d036dad5e937ae5e72292
  select(-(ends_with("comment")))
```

### dm object - relational database

```{r adding tables to the dm object, include=FALSE}
data_dm_no_keys <- dm(st, sp, pfas, co, sa, me)
data_dm_no_keys
data_dm_no_keys$st
data_dm_no_keys[c("st", "co")]
```

```{r defining primary keys}
data_dm_only_pks <- data_dm_no_keys %>% 
  dm_add_pk(table = st, columns = study_ID) %>% 
  dm_add_pk(sp, species_ID) %>% 
  dm_add_pk(pfas, pfas_ID) %>% 
  dm_add_pk(co, cohort_ID) %>% 
  dm_add_pk(sa, sample_ID) %>% 
  dm_add_pk(me, measurement_ID)
data_dm_only_pks
```

```{r defining foreign keys}
data_dm_all_keys <- 
  data_dm_only_pks %>% 
  dm_add_fk(table = co, columns = study_ID, ref_table = st) %>% 
  dm_add_fk(table = co, columns = species_ID, ref_table = sp) %>%
  dm_add_fk(table = sa, columns = cohort_ID, ref_table = co) %>%
  dm_add_fk(table = me, columns = sample_ID, ref_table = sa) %>%
  dm_add_fk(table = me, columns = pfas_ID, ref_table = pfas)
data_dm_all_keys
```
```{r visualization}
data_dm_all_keys %>% 
  dm_draw()
```
```{r integrity check}
data_dm_all_keys %>% 
  dm_examine_constraints()
```

```{r merging all tables into one big table}
dm_joined <- 
  data_dm_all_keys %>% 
  dm_flatten_to_tbl(.start = me, .recursive = TRUE)
dm_joined
```




I want to create a table with only the variables I need to create effect size IDs
```{r moving columns among dm objects}
me1 <- 
  data_dm_all_keys %>% 
  dm_select(me, measurement_ID | group_info | sample_ID | pfas_ID | mean_arithmetic | SD | n) %>% 
  dm_select(co, cohort_ID | species_ID | study_ID | sampling_location | life_stage) %>% 
  dm_select(pfas, pfas_ID) %>% 
  dm_select(sp, species_ID) %>% 
  dm_select(st, study_ID) %>% 
  dm_flatten_to_tbl(.start = me, .recursive = TRUE, .join = left_join)

colnames(me1)
```

Now I want to create a new column called "es_ID" which matches all the pairs of measurement I will use in the escalc() function.
Study, PFAS type, species, and sampling location must be the same, so I group by them.
The group (i.e., group_info) must be different

```{r}
# First, let's work on only two studies:
me2 <- 
  me1 %>% 
  dplyr::filter(study_ID == "S_001" | study_ID == "S_003")
# First, let's work on S_001
#me2 <- 
#  me1 %>% 
#  dplyr::filter(study_ID == "S_001" | study_ID == "S_003")

#group by
me3 <- 
  me1 %>% 
  dplyr::group_by(study_ID,
                  pfas_ID , 
                  species_ID,
                  #sampling_year, 
                  sampling_location) ## dplyr::mutate( es_ID = ifelse())


# TODO 

tdat <- data.frame(me1[me1$study_ID == "S_003" & me1$pfas_ID == "pfas_001", ])


adult <- tdat[tdat$group_info == "adult", 1]
progeny <-tdat[tdat$group_info == "progeny", 1]

ids <- expand.grid(adult_id = adult, progeny_id = progeny)

adult_id <- ids[[1]]
progeny_id <- ids[[2]]

pos_adult <- match(adult_id, tdat$measurement_ID)
adult_dat <- tdat[pos_adult, ]

pos_progeny <- match(progeny_id, tdat$measurement_ID)
progeny_dat <- tdat[pos_progeny, ]

#ndat<-as.data.frame(cbind(adult_dat, chick_dat))

ndat <- data.frame(measurement_ID_A = adult_dat[["measurement_ID"]],
           measurement_ID_C = progeny_dat[[ "measurement_ID"]],
           mean_arithmetic_A = adult_dat[["mean_arithmetic"]],
           mean_arithmetic_C =  progeny_dat[[ "mean_arithmetic"]]
             )

head(ndat)

# function

wide_table <- function(dat){

adult <- tdat[tdat$group_info == "adult", 1]
progeny <-tdat[tdat$group_info == "progeny", 1]

ids <- expand.grid(adult_id = adult, progeny_id = progeny)

adult_id <- ids[[1]]
progeny_id <- ids[[2]]

pos_adult <- match(adult_id, tdat$measurement_ID)
adult_dat <- tdat[pos_adult, ]

pos_progeny <- match(progeny_id, tdat$measurement_ID)
progeny_dat <- tdat[pos_progeny, ]

#ndat<-as.data.frame(cbind(adult_dat, chick_dat))

ndat <- data.frame(measurement_ID_A = adult_dat[["measurement_ID"]],
           measurement_ID_P = progeny_dat[[ "measurement_ID"]],
           mean_arithmetic_A = adult_dat[["mean_arithmetic"]],
           mean_arithmetic_P =  progeny_dat[[ "mean_arithmetic"]],
           SD_A = adult_dat[["SD"]],
           SD_P = progeny_dat[["SD"]],
           n_A = adult_dat[["n"]],
           n_P = progeny_dat[["n"]],
           life_stage_A = adult_dat[["life_stage"]],
           life_stage_P = progeny_dat[["life_stage"]],
           study_ID_A = adult_dat[["study_ID"]],
           study_ID_P = progeny_dat[["study_ID"]],
           species_ID_A = adult_dat[["species_ID"]],
           species_ID_P = progeny_dat[["species_ID"]],
           sample_ID_A = adult_dat[["sample_ID"]],
           sample_ID_P = progeny_dat[["sample_ID"]],
           cohort_ID_A = adult_dat[["cohort_ID"]],
           cohort_ID_P = progeny_dat[["cohort_ID"]],
           sample_type_A = adult_dat[["sample_type"]],
           sample_type_P = progeny_dat[["sample_type"]],
           sampling_location_A = adult_dat[["sampling_location"]],
           sampling_location_P = progeny_dat[["sampling_location"]]
             )
ndat

}


res <- wide_table(tdat)

test.list <- list(tdat, tdat)

ntable <- map_dfr(test.list, wide_table)

```
























### Effect size
The `lnRR_func` function is here used to calculate a log response ratio (lnRR) adjusted for small sample sizes. In addition, this formula accounts for correlated samples. 
For more details, see *Doncaster and Spake (2018) Correction for bias in meta-analysis of little-replicated studies. Methods in Ecology and Evolution; 9:634-644*

```{r function to calculate effect size}
# Custom function to calculate the lnRR 
lnRR_func <- function(Mc, Nc, Me, Ne, aCV2c, aCV2e){
  lnRR <- log(Me/Mc) + 
        0.5 * ((aCV2e/Ne) - (aCV2c/Nc))	
  lnRR
}
# Custom function to calculate the lnRR's sampling variance from independent designs (rTC = 0)
var_lnRR_ind <- function(Mc, Nc, Me, Ne, aCV2c, aCV2e){
  
  var_lnRR <- (aCV2c/Nc) + (aCV2e/Ne) 
  
  var_lnRR
}
# Mc: Concentration of PFAS of the raw (control) sample
# Nc: Sample size of the raw (control) sample
# Me: Concentration of PFAS of the cooked (experimental) sample
# Ne: Sample size of the cooked (experimental) sample 
# aCV2c: Mean coefficient of variation of the raw (control) samples
# aCV2e: Mean coefficient of variation of the cooked (experimental) samples
```

### Generating the Phylogenetic Tree

```{r get list of species, message = FALSE, echo = TRUE, eval = TRUE, warning = FALSE}
myspecies <- as.character(unique(sp$species_scientific_name)) #get list of species
str_sort(myspecies) #visual check
length(myspecies) #16 species
length(unique(myspecies)) #16 unique species names
```
Using *rotl* package to retrieve synthetic species tree from Open Tree of Life

Rotl is an R package (https://peerj.com/preprints/1471/) allowing access to synthetic phylogenetic tree available at Open Tree of Life database (https://opentreeoflife.org/). 

```{r rotl find species, message = FALSE, echo = TRUE, eval = TRUE, warning = FALSE, }
taxa <- tnrs_match_names(names = myspecies)
dim(taxa) #16 specias - all matched
table(taxa$approximate_match) #approximate matches
taxa[taxa$approximate_match==TRUE, ] ##ctenopharyngodon idell and Mylopharyngodon piceus are two species of carp from China, the other approximation is ok
```
Get the initial tree.  

```{r rotl species tree, warning = FALSE, results=FALSE}
tree <- tol_induced_subtree(ott_ids = taxa[["ott_id"]], 
                            label_format = "name")  
plot(tree,
     cex= 1, #font size
     label.offset =.1,
     no.margin = TRUE)
```
Check matching species and labels.

```{r re-check tree labels}
taxa2 <- taxa
tree2 <- tree

#check overlap and differences with taxa list
intersect(tree2$tip.label, taxa2$unique_name) #0
setdiff(tree2$tip.label, taxa2$unique_name) #16
setdiff(taxa2$unique_name, tree2$tip.label) #16

#check if the tree is really binary 
is.binary.tree(tree2) #TRUE
```
Save tree

```{r save final tree}
```

### Work on the datatables

```{r adding a table containing studies lnRRs to the dm}
lnRR <- 
  dm_joined %>% 
  group_by(study_ID) %>% 
  dplyr::summarise()
  

dm_with_summary$pfas_mean
dm_draw(dm_with_summary)
```








## Calculating lnRR and Variance
``` {r Calculating lnRR and Variance}
dat1adult <- filter(dat1, group_info == "adult")
dat1progeny <- filter(dat1, group_info == "egg")
lnRR <-
  dm_joined %>%
  dplyr::group_by(study_ID, group_info) %>% 
  escalc(measure = "ROM", n1i = dm_joined$n, n2i = dm_joined$n, m1i = dm_joined$mean_arithmetic, m2i = dm_joined$mean_arithmetic, sd1i = dm_joined$SD, sd2i = dm_joined$SD)
#joining the calculated lnRR and (yi) and variance (vi) into a new dataframe
dat2 <- bind_cols(dat1progeny, lnRR)
str(dat2)
```
```{r create the forest plot}
forest(dat2$yi, dat2$vi)
```

