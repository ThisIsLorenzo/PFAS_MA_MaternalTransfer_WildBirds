---
title: "Maternal PFAS transfer in wild birds: a systematic review and meta-analysis"
author: "L.Ricolfi"
date: '2022-06-28'
output: html_document
editor_options: 
  chunk_output_type: console
---

# Project title

*Maternal PFAS transfer in wild birds: a systematic review and meta-analysis*

# Research questions

1.  What is the overall maternal PFAS transfer (i.e., the ratio between PFAS concentration in both eggs and hatchling and the adult female) in wild birds, and how variable is it?

2.  Do physicochemical properties of PFAS compounds affect the maternal transfer efficiency in wild birds? Specifically, is the maternal transfer mediated by a compounds':

-   carbon chain length?
-   functional group?
-   molecular weight?

3.  Do biological factors of birds affect the maternal PFAS transfer efficiency? Specifically, is the maternal transfer mediated by:

-   feeding ecology or trophic position?
-   birds' body weight?
-   average clutch size?
-   average number of broods per year?
-   egg mass?
-   the type of adult bird's tissue analysed?
-   the type of egg's part or chick's tissue analysed?
-   the developmental stage of the offspring (i.e., chick vs egg)?

# Objectives

1.  Quantify the overall meta-analytic mean of maternal transfer ratio (i.e., Coffspring/Cfemale) and its variation.

2.  Identify and evaluate sources of heterogeneity related to PFAS properties:

-   Assess whether different types of PFAS have different transfer rates.
-   Estimate the variance explained for different carbon chain lengths, functional groups, and molecular masses of PFAS.

3.  Identify and evaluate sources of heterogeneity related to biological samples:

-   Assess whether the proportion of maternal transfer is statistically different between seabirds and non-seabirds.
-   Estimate the variance explained for different feeding ecology, body mass, the average number of eggs in a clutch, the average number of broods per year, egg mass, type of adult bird's tissue analysed, type of egg's part analysed, and developmental stage of the progeny.

# Purpose

This .Rmd document provides the code I used for data processing, data analysing, and visualization.

# Data model

A relational data model organizes extracted data from included studies into tables of rows and columns, and the relationships between the data are defined using primary and foreign keys includes my local data tables. This allows for efficient querying and data manipulation, and makes it easy to integrate data from multiple tables.

I extracted data from the included studies on six data tables:

-   **study_info**

-   **species_info**

-   **pfas_info**

-   **cohort_info**

-   **sample_info**

-   **measurements**

They are stored in [a repository on GitHub](https://github.com/ThisIsLorenzo/PFAS_MA_MaternalTransfer_WildBirds_Pilot/tree/main/Data)

# Data loading & processing

Set up knitr options

```{r setup, eval = TRUE, include = TRUE, message = FALSE, echo = TRUE,  warning = FALSE}
# knitr setting
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE, 
  tidy = TRUE,
  cache = TRUE, 
  echo=TRUE
)

rm(list = ls())
```

loading packages

```{r loading packages, results = 'hide'}
# Loading packages
pacman::p_load(tidyverse,
               readr,
               ape,
               curl,
               rotl,
               here,
               dm,
               dplyr,
               metafor,
               meta,
               forestplot,
               orchaRd,
               kableExtra,
               phytools,
               patchwork,
               clubSandwich)
```

loading the six data tables

```{r loading data, results = 'hide'}
st <- read_csv(here("Data", "study_info.csv"))
sp <- read_csv(here("Data", "species_info.csv"))
pfas <- read_csv(here("Data", "pfas_info.csv"))
co <- read_csv(here("Data", "cohort_info.csv"))
sa <- read_csv(here("Data", "sample_info.csv"))
me <- read_csv(here("Data", "measurement_info.csv"))
```

cleaning data

```{r cleaning data tables, results = 'hide'}
st <- st %>% 
  select(-("Timestamp")) %>%
  select(-(ends_with("comment")))
sp <- sp %>% 
  select(-("Timestamp")) %>%
  select(-(ends_with("comment")))
pfas <- pfas %>% 
  select(-("Timestamp")) %>% 
  select(-(ends_with("comment")))
co <- co %>% 
  select(-("Timestamp")) %>%
  select(-(ends_with("comment")))
sa <- sa %>% 
  select(-("Timestamp")) %>% 
  select(-(ends_with("comment")))
me <- me %>%
  select(-("Timestamp")) %>% 
  select(-(ends_with("comment")))
```

dm object without keys

```{r adding tables to the dm object, results = 'hide'}
data_dm_no_keys <- dm(st, sp, pfas, co, sa, me)
data_dm_no_keys
data_dm_no_keys$st
data_dm_no_keys[c("st", "co")]
```

defining primary keys

```{r defining primary keys, results = 'hide'}
data_dm_only_pks <- data_dm_no_keys %>% 
  dm_add_pk(table = st, columns = study_ID) %>% 
  dm_add_pk(sp, species_ID) %>% 
  dm_add_pk(pfas, pfas_ID) %>% 
  dm_add_pk(co, cohort_ID) %>% 
  dm_add_pk(sa, sample_ID) %>% 
  dm_add_pk(me, measurement_ID)
data_dm_only_pks
```

defining foreign keys

```{r defining foreign keys, results = 'hide'}
data_dm_all_keys <- 
  data_dm_only_pks %>% 
  dm_add_fk(table = co, columns = study_ID, ref_table = st) %>% 
  dm_add_fk(table = co, columns = species_ID, ref_table = sp) %>%
  dm_add_fk(table = sa, columns = cohort_ID, ref_table = co) %>%
  dm_add_fk(table = me, columns = sample_ID, ref_table = sa) %>%
  dm_add_fk(table = me, columns = pfas_ID, ref_table = pfas)
data_dm_all_keys
```

dm visualization and integrity check

```{r visualization, eval=FALSE}
data_dm_all_keys %>% 
  dm_draw()

data_dm_all_keys %>% 
  dm_examine_constraints()
```

The following chunk creates a new table that merges sa, co, and me. me includes only the variables we need to calculate effect sizes (i.e., min, max, median, etc. are removed)

```{r moving columns among dm objects}
me1 <- 
  data_dm_all_keys %>% 
  dm_select(me, measurement_ID | group_info | sample_ID | pfas_ID | mean_arithmetic | SD | n | limit_type) %>% 
  dm_select(sa, sample_ID : sample_type) %>% 
  dm_select(co, cohort_ID : data_pooled) %>% 
  dm_select(pfas, pfas_ID) %>% 
  dm_select(sp, species_ID) %>% 
  dm_select(st, study_ID) %>% 
  dm_flatten_to_tbl(.start = me, .recursive = TRUE, .join = left_join)

colnames(me1)
```

Now I want to create a new column called "es_ID" which matches all the pairs of measurement I will use in the escalc() function to calculate the effect size measurements. Study, PFAS type, species, and sampling location must be the same, so I group by them. The group (i.e., group_info) must be different, so that I pair adult-progeny in all possible combinations (different tissues in adults, eggs, chicks).

```{r}
list_dat <- 
  me1 %>% 
  dplyr::group_split(study_ID,
                  pfas_ID , 
                  species_ID,
                  sampling_location)

# tdat <- data.frame(me1[me1$study_ID == "S_003" & me1$pfas_ID == "pfas_001", ])
# 
# 
# adult <- tdat[tdat$group_info == "adult", 1]
# progeny <-tdat[tdat$group_info == "progeny", 1]
# 
# ids <- expand.grid(adult_id = adult, progeny_id = progeny)
# 
# adult_id <- ids[[1]]
# progeny_id <- ids[[2]]
# 
# pos_adult <- match(adult_id, tdat$measurement_ID)
# adult_dat <- tdat[pos_adult, ]
# 
# pos_progeny <- match(progeny_id, tdat$measurement_ID)
# progeny_dat <- tdat[pos_progeny, ]
# 
# #ndat<-as.data.frame(cbind(adult_dat, chick_dat))
# 
# ndat <- data.frame(measurement_ID_A = adult_dat[["measurement_ID"]],
#            measurement_ID_C = progeny_dat[[ "measurement_ID"]],
#            mean_arithmetic_A = adult_dat[["mean_arithmetic"]],
#            mean_arithmetic_C =  progeny_dat[[ "mean_arithmetic"]]
#              )

# head(ndat)

# function

wide_table <-
  function(dat)
    {

dat <-
  as.data.frame(dat)  
  
adult <-
  dat[dat$group_info == "adult", 1]
progeny <-
  dat[dat$group_info == "progeny", 1]

ids <-
  expand.grid(adult_id = adult,
              progeny_id = progeny)

adult_id <- ids[[1]]
progeny_id <- ids[[2]]

pos_adult <- match(adult_id, dat$measurement_ID)
adult_dat <- dat[pos_adult, ]

pos_progeny <- match(progeny_id, dat$measurement_ID)
progeny_dat <- dat[pos_progeny, ]

#ndat<-as.data.frame(cbind(adult_dat, chick_dat))

ndat <- data.frame(
           measurement_ID_A = adult_dat[["measurement_ID"]],
           measurement_ID_P = progeny_dat[[ "measurement_ID"]],
           mean_arithmetic_A = adult_dat[["mean_arithmetic"]],
           mean_arithmetic_P =  progeny_dat[[ "mean_arithmetic"]],
           SD_A = adult_dat[["SD"]],
           SD_P = progeny_dat[["SD"]],
           n_A = adult_dat[["n"]],
           n_P = progeny_dat[["n"]],
           life_stage_A = adult_dat[["life_stage"]],
           life_stage_P = progeny_dat[["life_stage"]],
           study_ID_A = adult_dat[["study_ID"]],
           study_ID_P = progeny_dat[["study_ID"]],
           species_ID_A = adult_dat[["species_ID"]],
           species_ID_P = progeny_dat[["species_ID"]],
           sample_type_A = adult_dat[["sample_type"]],
           sample_type_P = progeny_dat[["sample_type"]],
           sampling_location_A = adult_dat[["sampling_location"]],
           sampling_location_P = progeny_dat[["sampling_location"]],
           pfas_ID_A = adult_dat[["pfas_ID"]],
           pfas_ID_P = progeny_dat[["pfas_ID"]],
           limit_type_A = adult_dat[["limit_type"]],
           limit_type_P = progeny_dat[["limit_type"]],
           sampling_year_A = adult_dat[["sampling_year"]],
           sampling_year_P = progeny_dat[["sampling_year"]],
           sampling_month_A = adult_dat[["sampling_month"]],
           sampling_month_P = progeny_dat[["sampling_month"]],
           developmental_stage_A = adult_dat[["developmental_stage"]],
           developmental_stage_P = progeny_dat[["developmental_stage"]],
           breeding_stage = adult_dat[["breeding_stage"]],
           laying_order = progeny_dat[["laying_order"]],
           nest = adult_dat[["nest"]],
           body_weight_mean = adult_dat[["body_weight_mean"]],
           body_weight_sd = adult_dat[["body_weight_sd"]],
           egg_weight_mean = progeny_dat[["egg_weight_mean"]],
           egg_weight_sd = progeny_dat[["egg_weight_sd"]],
           data_pooled = adult_dat[["data_pooled"]]
             )
ndat

}


dat <- list_dat[[3]]

res <- wide_table(list_dat[[3]])
res

# this applies wide_table data to every item in this list
ntable <- map_dfr(list_dat, wide_table)
```

Create effect sizes column and tidy data

```{r}
ntable <- dplyr::mutate(ntable, 
                        es_ID = as.vector(001 : 412)) # add esID column
ntable$es_ID <-  sub("(.{1})", "es_\\1", ntable$es_ID) #add es_IDs
# ntable <- ntable[, c(27, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26)] # move es_ID column at the beginning
# the following columns are created in order to link the new ntable to the dm abject
ntable <- dplyr::mutate(ntable, 
                        study_ID =  ntable$study_ID_A) # add study_ID column
ntable <- dplyr::mutate(ntable,
                        species_ID =  ntable$species_ID_A) # add species_ID column
ntable <- dplyr::mutate(ntable,
                        pfas_ID =  ntable$pfas_ID_A) # add pfas_ID column

ntable <- dplyr::select(ntable, -c('study_ID_A', 
                                   'study_ID_P', 
                                   'species_ID_A', 
                                   'species_ID_P', 
                                   'pfas_ID_A',
                                   'pfas_ID_P'))
```

Remove effect sizes where both adult and progeny concentrations were under the limit of detection or quantification. This was an assumption made in the pre-registration. This is necessary to have meaningful response ratios.

```{r}
# Remove es_IDs where both limit_type_A AND limit_type_P are != NA
ntable <- 
  ntable %>% 
  dplyr::filter(is.na(limit_type_A) == "TRUE" |
               is.na(limit_type_P) == "TRUE")
```

Remove effect size measurements with NA in the mean concentration in the adult OR progeny. This is necessary for successful analysis because means cannot be "NA" in effect size calculations.

```{r}
ntable <- 
  ntable %>% 
  dplyr::filter(is.na(mean_arithmetic_A) == "FALSE" &
                  is.na(mean_arithmetic_P) == "FALSE")
```

#DM object

Rebuilt the dm object with the new ntable.

```{r adding the ntable to the dm object, include=FALSE}
nt <- ntable
data_dm_no_keys <- dm(st, sp, pfas, nt)

data_dm_only_pks <- data_dm_no_keys %>%
  dm_add_pk(table = st, columns = study_ID) %>%
  dm_add_pk(sp, species_ID) %>%
  dm_add_pk(pfas, pfas_ID) %>%
  dm_add_pk(nt, es_ID)
data_dm_only_pks

data_dm_all_keys <-
  data_dm_only_pks %>%
  dm_add_fk(table = nt, columns = study_ID, ref_table = st) %>% 
  dm_add_fk(table = nt, columns = species_ID, ref_table = sp) %>% 
  dm_add_fk(table = nt, columns = pfas_ID, ref_table = pfas)
data_dm_all_keys
```

```{r, eval=FALSE}
data_dm_all_keys %>% 
  dm_draw()

data_dm_all_keys %>% 
  dm_examine_constraints()
```

Merging the dm tables in a wide table.

```{r merging all tables into one big table}
nt <-
  data_dm_all_keys %>%
  dm_flatten_to_tbl(.start = nt, .recursive = TRUE)
nt
```

Remove characters from carbon chain length and molecular weight

```{r}
nt$carbon_chain_length[nt$carbon_chain_length == "mixed"] <- NA
nt$carbon_chain_length <- as.numeric(nt$carbon_chain_length)

nt$molecular_weight[nt$molecular_weight == "mixed"] <- NA
nt$molecular_weight <- as.numeric(nt$molecular_weight)
```

# Functions

The `lnRR_func` function is here used to calculate a log response ratio (lnRR) adjusted for small sample sizes. In addition, this formula accounts for correlated samples. For more details, see *Doncaster and Spake (2018) Correction for bias in meta-analysis of little-replicated studies. Methods in Ecology and Evolution; 9:634-644*

```{r function to calculate effect size}
#Changing columns names to make them shorter
colnames(nt)[3] <- "mean_A"
colnames(nt)[4] <- "mean_P"
colnames(nt)[5] <- "sd_A"
colnames(nt)[6] <- "sd_P"

# Custom function to calculate the lnRR 
lnRR_func <- function(mean_A,
                      n_A,
                      mean_P,
                      n_P,
                      aCV2a,
                      aCV2p)
  {
  lnRR <- log(mean_P/mean_A) + 0.5 * ((aCV2p/n_P) - (aCV2a/n_A))	
  
  lnRR
  }
# Custom function to calculate the lnRR's sampling variance from independent designs (rTC = 0)
var_lnRR_ind <- function(mean_A,
                         n_A,
                         mean_P, 
                         n_P, 
                         aCV2a, 
                         aCV2p)
  {
  
  var_lnRR <- (aCV2a/n_A) + (aCV2p/n_P) 
  
  var_lnRR
  }
# Mc: Concentration of PFAS of the raw (control) sample
# Nc: Sample size of the raw (control) sample
# Me: Concentration of PFAS of the cooked (experimental) sample
# Ne: Sample size of the cooked (experimental) sample 
# aCV2c: Mean coefficient of variation of the raw (control) samples
# aCV2e: Mean coefficient of variation of the cooked (experimental) samples

```

# Phylogenetic information

Import phylogenetic information and calculate phylogenetic variance-covariance matrix

NOTE: The phylogenetic tree was generated in the `tree_MA_MT_PFAS.Rmd` document

```{r, fig.height=10, fig.width = 8}
tree <- read.tree(here("R", "phylogenetic_tree.tre")) # Import phylogenetic tree (see tree_MA_MT_PFAS.Rmd for more details) 
tree <- compute.brlen(tree) # Generate branch lengths 
cor_tree <- vcv(tree,corr = T) # Generate phylogenetic variance-covariance matrix 

nt2 <- nt

nt2$Phylogeny <- as.factor(str_replace(nt2$species_scientific_name, " ", "_")) # Add the `phylogeny` column to the data frame
colnames(cor_tree) %in% nt2$Phylogeny # Check correspondence between tip names and data frame

# Rename species names that do not match
levels(nt2$Phylogeny)[levels(nt2$Phylogeny) == "Larus_audouinii"] <- "Ichthyaetus_audouinii"
levels(nt2$Phylogeny)[levels(nt2$Phylogeny) == "Phalacrocorax_aristotelis"] <- "Gulosus_aristotelis"
levels(nt2$Phylogeny)[levels(nt2$Phylogeny) == "Diomedea_immutabilis"] <- "Phoebastria_immutabilis"

# checking all species are in the data
match(unique(nt2$Phylogeny), colnames(cor_tree))
match(nt2$Phylogeny, colnames(cor_tree))
# plotting tree
plot(tree)
```

# Effect sizes

## Missing standard deviation values

How many sd values are missing in the data frame?

```{r}
sum(is.na(nt$sd_P))
#[1] 81
sum(is.na(nt$sd_A))
#[1] 54
```

I need to estimate these missing SDs. To do so, I follow the methods proposed by Nakagawa et al., 2022 ([A robust and readily implementable method for the meta-analysis of response ratios with and without missing standard deviations](https://ecoevorxiv.org/repository/view/3753/)).

### Geary's Test

How well missing SD methods perform (and indeed whether lnRR is suitable at all) depends on whether lnRR is normally distributed. We can use a modified Geary's Test (Lajeunesse 2015) to ascertain effects that may be problematic.

```{r}
# Function to calculate Geary's "number"
  geary <- function(mean, 
                    sd, 
                    n)
    {
    (1 / (sd / mean)) * ((4*n)^(3/2) / (1 + 4*n))
    }

# Geary's test; assumption of normality assumed to be approximately correct when values are >= 3.
nt <- nt %>% 
         mutate(geary_control = geary(mean_A,
                                      sd_A,
                                      n_A),
                    geary_trt = geary(mean_P, 
                                      sd_P,
                                      n_P),
                   geary_test = ifelse(geary_control >= 3 & geary_trt >= 3, "pass", "fail"))
# How many fail?
geary_res <- nt %>% 
      group_by(geary_test) %>% 
      summarise(n = n()) %>% 
      data.frame()

geary_res
#   geary_test   n
# 1       fail   6
# 2       pass 238
# 3       <NA> 127
```

Overall, it looks like we have 6 effects that fail the test. Lajeunesse (2015) recommend doing a sensitivity analysis with and without the effect sizes that fail the test.

### All-cases Method

To implement the all-cases Method, we need to first calculate the between study CV. We will do this with the `cvg_avg` function. Here, we need to do this for the adults and progeny groups as follows, such that variable b_CV_1 and b_CV_2 are the averages for the adults and progeny groups, respectively:

```{r}
# Calculate the average between study CV, which will replace missing values.
cv_avg <- function(x, 
                   sd, 
                   n, 
                   group,
                   data,
                   label = NULL,
                   sub_b = TRUE, 
                   cv2=FALSE){

  # Check if the name is specified or not. If not, then assign it the name of the mean, x, variable input in the function. https://stackoverflow.com/questions/60644445/converting-tidyeval-arguments-to-string
  
if(is.null(label)){
  label <- purrr::map_chr(enquos(x), rlang::as_label)
}
  
weighted_CV <- function(sd, x, n, cv2=FALSE){
  if(cv2){
    weighted.mean(na_if((sd / x)^2, Inf), n, na.rm = TRUE)
  }else{
    weighted.mean(na_if((sd / x), Inf), n, na.rm = TRUE)^2
  }
}
# Calculate between study CV. Take weighted mean CV within study, and then take a weighted mean across studies of the within study CV. Weighted based on sample size and pooled sample size.
  b_grp_cv_data <- nt %>%
    dplyr::group_by({{group}}) %>%
    dplyr::mutate(w_CV2 = weighted_CV({{sd}}, 
                                         {{x}}, 
                                         {{n}},
                                         cv2=cv2),
                     n_mean = mean({{n}}, na.rm = TRUE)) %>%
    dplyr::ungroup(.) %>%
    dplyr::mutate(b_CV2 = weighted.mean(w_CV2,
                                        n_mean,
                                        na.rm = TRUE), .keep = "used")

# Make sure that label of the calculated columns is distinct from any other columns
  names(b_grp_cv_data) <- paste0(names(b_grp_cv_data), "_", label)

# Append these calculated columns back to the original data and return the full dataset.
  if(sub_b){
    b_grp_cv_data <- b_grp_cv_data %>% 
      dplyr::select(grep("b_", names(b_grp_cv_data)))
    dat_new <- cbind(data, b_grp_cv_data)
  } else {
    dat_new <- cbind(data, b_grp_cv_data)
  }

  return(data.frame(dat_new))
}
  
# Calculate the average between study CV, which will replace missing values
nt2 <- cv_avg(x = mean_A,
             sd = sd_A,
             n = n_A,
             group = study_ID,
             label = "1",
             data = nt2)

nt2 <- cv_avg(x = mean_P,
             sd = sd_P,
             n = n_P,
             group = study_ID,
             label = "2",
             data = nt2)
```

```{r Calculating lnRR and Variance}
# Calculate the squared coefficient of variation for adult and progeny groups

# This part of the chunk has been called out as we have already estimated b_CV2_1 and b_CV2_2 in the previous chunk.

# aCV2 <- nt2 %>% 
#   group_by(study_ID) %>%
#   summarise(CV2a = mean((sd_A/mean_A)^2, na.rm = T),
#             CV2p = mean((sd_P/mean_P)^2, na.rm = T)) %>% 
#   ungroup() %>% # ungroup 
#   summarise(aCV2a = mean(CV2a, na.rm = T), # Mean CV^2 for adult and progeny groups across studies 
#             aCV2p = mean(CV2p, na.rm = T))

lnRR <- lnRR_func(mean_A = nt2$mean_A,
                  n_A = nt2$n_A,
                  mean_P = nt2$mean_P,
                  n_P = nt2$n_P,
                  aCV2a = nt2$b_CV2_1,
                  aCV2p = nt2$b_CV2_2)

var_lnRR <- var_lnRR_ind(mean_A = nt2$mean_A,
                         n_A = nt2$n_A,
                         mean_P = nt2$mean_P,
                         n_P = nt2$n_P,
                         aCV2a = nt2$b_CV2_1,
                         aCV2p = nt2$b_CV2_2) 



dat <- nt2 %>% 
  dplyr::mutate(N_tilde = (n_A*n_P)/(n_A + n_P)) # getting effective sample size

dat <- cbind(dat, lnRR, var_lnRR) # Merge effect sizes with the data frame
```

Now, we need to account for correlated errors (i.e. effectively dividing the weight of the correlated estimates by half) because some effect sizes share the same control(adult). For this purpose, I calculate the variance-covariance from the log response ratio variance. Variance-covariance is a measure of how two random variables are related. The variance-covariance matrix is a square matrix that shows the variances and covariances of a set of random variables. The diagonal elements of the matrix show the variances of the individual random variables, while the off-diagonal elements show the covariances between pairs of variables.

```{r}

VCV_lnRR <- impute_covariance_matrix(dat$var_lnRR,
                                     cluster = dat$measurement_ID_A, 
                                     r = 0.5)

# # Making the same in a data set without albumen (as it brings strong heterogeneity)

dat_noalbumen <-  dat %>% 
  dplyr::filter(sample_type_P != "albumen")

VCV_lnRR_noalbumen <- impute_covariance_matrix(dat_noalbumen$var_lnRR,
                                     cluster = dat_noalbumen$measurement_ID_A, 
                                     r = 0.5)
```

# Sensitivity analysis - Data

Here I create three data sets to run a sensitivity analysis. The first data set (i.e., dat) will include all the data. The second (i.e., *dat2*) one will drop out data that are from pooled samples (i.e., from adult male + female pooled data) and/or data from adults and progeny that come from different nests. The third one (i.e., *dat3*) will drop out all effect size measures where the PFAS concentration in the adult OR progeny is below the limit of detection/quantification. Eval is false in the following chunks.

```{r, eval=FALSE}
dat2 <-
  dat %>%
  dplyr::filter(data_pooled == "No" & nest == "Yes")
```

Remove all effect sizes where concentration in the adult OR progeny is below the limit of detection/quantification

```{r, eval=FALSE}
Remove es_IDs where limit_type_A OR limit_type_P is != NA
dat3 <-
  dat2 %>%
  dplyr::filter(if_all(c(limit_type_A, limit_type_P), ~is.na(.)))
```

# Distribution of effect sizes

Plotting effect size measurements distribution

```{r, fig.height=8, fig.width=15, , eval=FALSE}
mean
ggplot(dat, aes(x=lnRR))+ geom_histogram(fill = "salmon", 
                                         col = "black",
                                         binwidth = 0.2) + theme_classic()
# variance
ggplot(dat, aes(x=var_lnRR))+ geom_histogram(fill = "salmon", 
                                             col = "black",
                                             binwidth = 0.05) + theme_classic()
# log variance
ggplot(dat, aes(x=var_lnRR))+ geom_histogram(fill = "salmon", 
                                             col = "black",
                                             binwidth = 0.05) + scale_x_log10()+theme_classic()
```

# Forest plot of effect size measurements
*WORK IN PROGRESS*
```{r create the forest plot, , eval=FALSE}
forest.meta(
  dat,
  yi = "lnRR", vi = "var_nlRR")
```

# Table of sample sizes

```{r}
table_sample_sizes <- dat %>% 
  dplyr::summarise('studies' = n_distinct(study_ID),
                   'species' = n_distinct(Phylogeny),
                   'pfas type' = n_distinct(pfas_ID),
                   'Adult sample types' = n_distinct(sample_type_A),
                   'Progeny sample types' = n_distinct(sample_type_P),
                   'Breeding stage' = n_distinct(breeding_stage),
                   'Laying order' = n_distinct(laying_order),
                   'Same nest' = n_distinct(nest),
                   'effect sizes' = n_distinct(es_ID),
                   'effect sizes (eggs)' = n_distinct(es_ID[life_stage_P == "egg"]),
                   'studies (eggs)' = n_distinct(study_ID[life_stage_P == "egg"]),
                   'species (eggs)' = n_distinct(Phylogeny[life_stage_P == "egg"]),
                   'effect sizes (chicks)' = n_distinct(es_ID[life_stage_P == "chick"]),
                   'studies (chicks)' = n_distinct(study_ID[life_stage_P == "chick"]),
                   'species (chicks)' = n_distinct(Phylogeny[life_stage_P == "chick"])
                   )

table_sample_sizes <- t(table_sample_sizes)

colnames(table_sample_sizes) <- "n (sample size)"

kable(table_sample_sizes) %>% 
  kable_styling("striped", position="left")
```

# Summary of the dataset

```{r}
kable(summary(dat), "html") %>% 
  kable_styling("striped", position = "left") %>% 
    scroll_box(width = "100%", 
               height = "500px")
```

# Meta-analysis {.tabset}

## Intercept meta-analytical model

Now that we calculated the effect size measures, we fit an intercept only, meta-analytic model.

Read <https://daniel1noble.github.io/orchaRd/> for more details on making pretty plots.

Intercept meta-analytic model:

```{r, eval=FALSE}
ma_model1 <- rma.mv(yi = lnRR,
             V = VCV_lnRR, # Add `VCV_lnRR` to account for correlated errors
             random = list(~1|study_ID, # Identity of the study
                            ~1|Phylogeny, # Phylogenetic correlation between species
                            ~1|species_ID, # Identity of the species
                            ~1|pfas_ID, # Type of PFAS
                            ~1|es_ID # Effect size identity
              ),
             R = list(Phylogeny = cor_tree),
             test = "t",
             data = dat)

save(ma_model1, file = here("Rdata", "ma_model1.RData"))
```

```{r}
load(here("RData", "ma_model1.RData"))
summary(ma_model1)
i2_ml(ma_model1)
```

```{r}
# TODO
# ma_model1r <- robust(ma_model1, cluster=study_ID, clubSandwich = T)
# summary(ma_model1r)
# orchard_plot(ma_model1,
#              group = "study_ID",
#              data = dat, 
#              xlab = "lnRR")
```


From previous graph we can see that overall estimate from a random-effects meta-analysis of 371 effect sizes is centered on zero, with a 95% CI that spans the line of no-effect.

Now,
Use i2_ml function to obtain the total I^2.
The I^2 statistic (J. P. Higgins and Thompson 2002) quantifies between-study heterogeneity. It is defined as the percentage of variability in the effect sizes that is not caused by sampling error.
I^2 draws on the assumption that Q follows a χ^2 distribution with K−1 degrees of freedom under the null hypothesis of no heterogeneity.
It is calculated as the percentage of total variation in effect sizes that is due to between-study heterogeneity, rather than sampling error within each study.
More info here: https://bookdown.org/MathiasHarrer/Doing_Meta_Analysis_in_R/heterogeneity.html

```{r}
I2 <- orchaRd::i2_ml(ma_model1)

orchaRd::orchard_plot(ma_model1,
                      mod="1",
                      group = "study_ID",
                      data = dat,
                      xlab = "lnRR") + 
  annotate(geom="text",
           x= 0.80,
           y= 1, 
           label= paste0("italic(I)^{2} == ", round(I2[1],4)),
           color="black",
           parse = TRUE, 
           size = 5) +
  scale_fill_manual(values="grey") +
  scale_colour_manual(values="grey")
```

A value of I^2 = 99 means that 99% of the total variation in effect sizes is due to between-study heterogeneity, indicating a high level of inconsistency or heterogeneity among the studies included in the analysis. This may suggest that the studies are not comparable, or that there are important differences in the methods, populations, or outcomes that are not accounted for in the analysis. In such cases, it may be difficult to draw reliable conclusions from the meta-analysis.


We can now draw a comparable caterpillar plot by using the function caterpillars. This caterpillar plot does not tell us anything new that the orchard plot didn't. But it can be compared to the orchard plot.

```{r,eval=FALSE}
orchaRd::caterpillars(model1, group = "study_ID",data = dat, xlab = "lnRR") 
```

Meta-analytic model filtering out albumen:

```{r, eval=FALSE}
ma_model1_noalbu <- rma.mv(yi = lnRR,
             V = VCV_lnRR_noalbumen,
             random = list(~1|es_ID,
                           ~1|study_ID),
             test = "t",
             data = dplyr::filter(dat, sample_type_P != "albumen" ))

save(ma_model1_noalbu, file = here("Rdata", "ma_model1_noalbu.RData"))
```

```{r}
load(here("RData", "ma_model1_noalbu.RData"))
summary(ma_model1_noalbu)
i2_ml(ma_model1_noalbu)
orchard_plot(ma_model1_noalbu,
             group = "study_ID", 
             data = dplyr::filter(dat, sample_type_P != "albumen" ), 
             xlab = "lnRR")
```

```{r, eval=FALSE}
I2_noalbu <- orchaRd::i2_ml(ma_model1_noalbu)

orchaRd::orchard_plot(ma_model1_noalbu,
                      mod="1",
                      group = "study_ID",
                      data = dplyr::filter(dat, sample_type_P != "albumen" ),
                      xlab = "lnRR") + 
  annotate(geom="text",
           x= 0.80,
           y= 1, 
           label= paste0("italic(I)^{2} == ", round(I2_noalbu[1],4)),
              color="black", parse = TRUE, size = 5) +
  scale_fill_manual(values="grey") +
  scale_colour_manual(values="grey")
```

The value of I^2 is still very high (i.e., 97%).

## Determine the random effect structure

Test the random effects of five variables: study's identity, Phylogenetic correlation between species, identity of the species, type of PFAS, and effect size identity.

```{r, eval=FALSE}
ma_model2 <- rma.mv(lnRR, VCV_lnRR,
              random = list(~1|study_ID,
                            ~1|Phylogeny,
                            ~1|species_ID, 
                            ~1|pfas_ID, 
                            ~1|es_ID
              ),
              R = list(Phylogeny = cor_tree),
              test = "t",
              data = dat,
              sparse = TRUE) # Make the model run faster

save(ma_model2, file = here("Rdata", "ma_model2.RData"))
```

```{r}
load(here("RData", "ma_model2.RData"))
summary(ma_model2)
i2_ml(ma_model2)
```

Phylogeny does not explain for any variance! (sigma squared = 0.0000)

Thus, we remove it from the model.

The effects of the other grouping variables are assumed to be random and are accounted for in the analysis. This allows the model to account for any differences between the groups and to provide more accurate estimates of the relationships between the variables.

Now, Determine the random effect structure filtering out albumen

```{r, eval=FALSE}
ma_model2_noalbu <- rma.mv(lnRR,
                        VCV_lnRR_noalbumen, # Add `VCV_lnRR` to account for correlated errors between cohorts (shared_controls)
                        random = list(~1|study_ID,
                                      ~1|Phylogeny, 
                                      ~1|species_ID, 
                                      ~1|pfas_ID,
                                      ~1|es_ID
                                      ),
                        R = list(Phylogeny = cor_tree), # Assign the 'Phylogeny' argument to the phylogenetic variance-covariance matrix
                        test = "t",
                        data = dplyr::filter(dat, sample_type_P != "albumen" ),
                        sparse = TRUE)

save(ma_model2_noalbu, file = here("Rdata", "ma_model2_noalbu.RData"))
```

```{r}
load(here("RData", "ma_model2_noalbu.RData"))
summary(ma_model2_noalbu)
i2_ml(ma_model2_noalbu)
orchard_plot(ma_model2_noalbu, 
             group = "study_ID", 
             data = dplyr::filter(dat, sample_type_P != "albumen" ),
             xlab = "lnRR")
```

Phylogeny does not explain for any variance in this case as well!

## Meta-regression models

Now that the effects of the grouping variables are modeled as random effects, we include in the model additional variables (moderators/predictors) to explain heterogeneity among effect sizes (i.e., meta-regression). Moderators are tested for their overall effect on the maternal PFAS transfer. The moderators I am going to include in the model are:

-   type of progeny's tissue
-   type of adult's tissue
-   PFAS carbon chain length
-   PFAS molecular weight
-   Seabirds vs non-seabirds
-   ...
-   ...
-   ...

### Tissue - progeny

Does "sample_type_P" impact our results on the overall mean and variance?

```{r, eval=FALSE}
mr_model1 <- rma.mv(lnRR, VCV_lnRR,
              mod = ~ sample_type_P,# + sample_type_A,
              random = list(~1|study_ID,
                            ~1|species_ID,
                            ~1|pfas_ID,
                            ~1|es_ID
                            ),
              test = "t",
              data = dat,
              sparse = TRUE)
save(mr_model1, file = here("Rdata", "mr_model1.RData"))
```

```{r}
load(here("RData", "mr_model1.RData"))
summary(mr_model1)
i2_ml(mr_model1)
orchard_plot(mr_model1,
             mod = "sample_type_P",
             group = "study_ID", 
             data = dat,
             xlab = "lnRR")
```

### Tissue - adult

Does "sample_type_A" impact our results on the overall mean and variance?

```{r, eval=FALSE}
mr_model2 <- rma.mv(lnRR, VCV_lnRR,
              mod = ~ sample_type_A,
              random = list(~1|study_ID, 
                            ~1|species_ID,
                            ~1|pfas_ID, 
                            ~1|es_ID 
              ),
              test = "t",
              data = dat,
              sparse = TRUE)
save(mr_model2, file = here("Rdata", "mr_model2.RData"))
```

```{r}
load(here("RData", "mr_model2.RData"))
summary(mr_model2)
i2_ml(mr_model2)
orchard_plot(mr_model2, 
             mod = "sample_type_A", 
             group = "study_ID", 
             data = dat, 
             xlab = "lnRR")
```

### PFAS carbon chain length

```{r, eval=FALSE}
mr_model3 <- rma.mv(lnRR, VCV_lnRR,
              mod = ~ carbon_chain_length,
              random = list(~1|study_ID, 
                            ~1|species_ID,
                            ~1|pfas_ID, 
                            ~1|es_ID 
              ),
              test = "t",
              data = dat,
              sparse = TRUE)

save(mr_model3, file = here("Rdata", "mr_model3.RData"))
```

```{r}
load(here("RData", "mr_model3.RData"))
summary(mr_model3)
i2_ml(mr_model3)
bubble_plot(mr_model3,
            mod = "carbon_chain_length",
            group = "study_ID", 
            data =dat, 
            xlab = "carbon_chain_length")
```

Filtering out albumen

```{r, eval = FALSE}
mr_model3_noalbumen <- rma.mv(lnRR, 
                              VCV_lnRR_noalbumen,
                              mod = ~ carbon_chain_length,
                              random = list(~1|study_ID,
                                            ~1|species_ID,
                                            ~1|pfas_ID,
                                            ~1|es_ID
                                            ),
                              test = "t",
                              data = dplyr::filter(dat, sample_type_P != "albumen"),
                              sparse = TRUE)
save(mr_model3_noalbumen, file = here("Rdata", "mr_model3_noalbumen.RData"))
```

```{r}
load(here("RData", "mr_model3_noalbumen.RData"))
summary(mr_model3_noalbumen)
i2_ml(mr_model3_noalbumen)
bubble_plot(mr_model3_noalbumen, 
            mod = "carbon_chain_length",
            group = "study_ID", 
            data =dplyr::filter(dat, sample_type_P != "albumen") ,
            xlab = "carbon_chain_length")
```

### PFAS molecular weight

```{r, eval=FALSE}
mr_model4 <- rma.mv(lnRR, VCV_lnRR,
              mod = ~ molecular_weight,
              random = list(~1|study_ID, 
                            ~1|species_ID,
                            ~1|pfas_ID, 
                            ~1|es_ID 
              ),
              test = "t",
              data = dat,
              sparse = TRUE)
save(mr_model4, file = here("Rdata", "mr_model4.RData"))
```

```{r, eval=FALSE}
load(here("RData", "mr_model4.RData"))
summary(mr_model4)
i2_ml(mr_model4)
bubble_plot(mr_model4, 
            mod = "molecular_weight", 
            group = "study_ID",
            data =dat,
            xlab = "molecular_weight")

# Pearson's correlation
cor.test(dat$carbon_chain_length, dat$molecular_weight) #extremely high correlated (cor=0.9515476)
```

Filtering out albumen

```{r, eval = FALSE}
mr_model4_noalbumen <- rma.mv(lnRR, 
                              VCV_lnRR_noalbumen,
                              mod = ~ molecular_weight,
                              random = list(~1|study_ID,
                                            ~1|species_ID,
                                            ~1|pfas_ID,
                                            ~1|es_ID
                                            ),
                              test = "t",
                              data = dplyr::filter(dat, sample_type_P != "albumen"),
                              sparse = TRUE)
save(mr_model4_noalbumen, file = here("Rdata", "mr_model4_noalbumen.RData"))
```

```{r}
load(here("RData", "mr_model4_noalbumen.RData"))
summary(mr_model4_noalbumen)
i2_ml(mr_model4_noalbumen)
bubble_plot(mr_model4_noalbumen,
            mod = "molecular_weight", 
            group = "study_ID", 
            data =dplyr::filter(dat, sample_type_P != "albumen"),
            xlab = "molecular_weight")
```

### Functional group

```{r, eval=FALSE}
mr_model6 <- rma.mv(lnRR, VCV_lnRR,
              mod = ~ functional_group - 1,
              random = list(~1|study_ID, 
                            ~1|species_ID,
                            ~1|pfas_ID, 
                            ~1|es_ID 
              ),
              test = "t",
              data = dat,
              sparse = TRUE)
save(mr_model6, file = here("Rdata", "mr_model6.RData"))
```

```{r}
load(here("RData", "mr_model6.RData"))
summary(mr_model6)
i2_ml(mr_model6)
orchard_plot(mr_model6,
             mod = "functional_group",
             group = "study_ID",
             data =dat, 
             xlab = "lnRR",
             angle = 45)
```

## Mulit-moderator models

### some testing

```{r}

dat$albumen <- ifelse(dat$sample_type_P == "albumen", "albumen", "others")

mr_modelX <- rma.mv(lnRR, VCV_lnRR,
              mod = ~ albumen*carbon_chain_length,
              random = list(~1|study_ID,
                            ~1|species_ID,
                            ~1|pfas_ID,
                            ~1|es_ID 
              ),
              test = "t",
              data = dat,
              sparse = TRUE)

summary(mr_modelX)

orchard_plot(mr_modelX,
             mod = "albumen",
             group = "study_ID",
             data =dat, 
             xlab = "lnRR", 
             #xlab = "Carbon chain length",
             at = list(carbon_chain_length = c(6, 12, 16)),
             by = "carbon_chain_length" )

bubble_plot(mr_modelX,
             mod = "carbon_chain_length",
             group = "study_ID",
             data =dat, 
             ylab = "lnRR", 
             xlab = "Carbon chain length",
             by = "albumen" ,
            g = TRUE)

mr_modelX1 <- rma.mv(lnRR, VCV_lnRR,
              mod = ~ functional_group - 1 + scale(carbon_chain_length),
              random = list(~1|study_ID, 
                            ~1|species_ID,
                            ~1|pfas_ID, 
                            ~1|es_ID 
              ),
              test = "t",
              data = dat,
              sparse = TRUE)

summary(mr_modelX1)

orchard_plot(mr_modelX1,
             mod = "functional_group",
             group = "study_ID",
             data =dat, 
             xlab = "lnRR", 
             #xlab = "Carbon chain length",
             at = list(carbon_chain_length = c(6, 12, 16)),
             by = "carbon_chain_length" )

```




Filtering out albumen

```{r, eval=FALSE}
mr_model6_noalbumen <- rma.mv(lnRR, VCV_lnRR_noalbumen,
              mod = ~ functional_group,
              random = list(~1|study_ID, 
                            ~1|species_ID,
                            ~1|pfas_ID, 
                            ~1|es_ID 
              ),
              test = "t",
              data = dplyr::filter(dat, sample_type_P != "albumen"),
              sparse = TRUE)
save(mr_model6_noalbumen, file = here("Rdata", "mr_model6_noalbumen.RData"))
```

```{r}
load(here("RData", "mr_model6_noalbumen.RData"))
summary(mr_model6_noalbumen)
i2_ml(mr_model6_noalbumen)
orchard_plot(mr_model6_noalbumen,
             mod = "functional_group",
             group = "study_ID", 
             data =dplyr::filter(dat, sample_type_P != "albumen"),
             xlab = "lnRR")
```

# Publication bias

Here I test for publication bias using the year of publication.

```{r, eval = FALSE}
mr_model_pb <- metafor::rma.mv(lnRR,
                            var_lnRR,
                            mods = ~ year_publication,
                            random = list(~1|study_ID, 
                            ~1|species_ID,
                            ~1|pfas_ID, 
                            ~1|es_ID
                            ),
                            data = dat)
save(mr_model_pb, file = here("Rdata", "mr_model_pb.RData"))
```

```{r}
load(here("RData", "mr_model_pb.RData"))
summary(mr_model_pb) # No publication bias (p-val = 0.3233)
pb_bubble <- orchaRd::mod_results(mr_model_pb,
                                  mod = "year_publication",
                                  group = "study_ID",
                                  data = dat)

orchaRd::bubble_plot(pb_bubble, 
                     data = dat,
                     group = "study_ID",
                     mod = "year_publication",
                     xlab = "Year", 
                     legend.pos = "top.left")
```

# Sensitivity analysis - Models

-   Run a sensitivity analysis with and without the effect sizes that fail Geary's test.

# Tries

Here I have random stuff I am testing atm

Check extreme lnRR values

```{r}
extreme_values <- 
  dat %>%
  dplyr::filter(lnRR < -4 | lnRR > 4)
colnames(extreme_values)
extreme_values <- 
  extreme_values[, c(57, 58, 1 : 56)]
view(extreme_values)
extreme_values <-
  extreme_values %>%
  dplyr::select(-c(mean_A, mean_P, sd_A, sd_P, n_A, n_P))
```

```{r}
ggplot(data=dplyr::filter(dat, life_stage_P == "egg"),
       aes(x=sample_type_P, y=lnRR, color = sample_type_A)) +
  geom_point(size = 5) +
  theme_minimal()
```

```{r}
boxplot( lnRR ~ sample_type_P, data = dplyr::filter(dat, life_stage_P == "egg"),
        col = c("green","yellow","purple"))
```
