---
title: "Maternal PFAS transfer in wild birds: a systematic review and meta-analysis"
author: "L.Ricolfi"
date: '2022-06-28'
output: html_document
editor_options: 
  chunk_output_type: console
---

# Project

Maternal PFAS transfer in wild birds: a systematic review and meta-analysis

# Purpose

This .Rmd document provides the code we used for data processing and data visualization.

# Data model

We use a dm object to create a relational data model from our local data tables. Six data tables contain data extracted from the included studies. The six tables are named as follow:

-   **study_info**

-   **species_info**

-   **pfas_info**

-   **cohort_info**

-   **sample_info**

-   **measurements**

```{r setup, include = FALSE}
# knitr setting
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE, 
  tidy = TRUE,
  cache = TRUE, 
  echo=TRUE
)
```

```{r loading packages, message = FALSE, echo = TRUE, eval = TRUE, warning = FALSE}
library(tidyverse)
library(readr)
library(ape, curl)
library(rotl)
library(here)
library(dm)
library(dplyr)
library(metafor)
library(meta)
library(orchaRd)
library(kableExtra)
```

```{r loading data, include=FALSE}
st <- read_csv(here("Data", "study_info.csv"))
sp <- read_csv(here("Data", "species_info.csv"))
pfas <- read_csv(here("Data", "pfas_info.csv"))
co <- read_csv(here("Data", "cohort_info.csv"))
sa <- read_csv(here("Data", "sample_info.csv"))
me <- read_csv(here("Data", "measurement_info.csv"))
```

```{r cleaning - removing unnecessary columns (i.e., "Timestamp" and comment columns)}
st <- st %>% 
  select(-("Timestamp")) %>%
  select(-(ends_with("comment")))
sp <- sp %>% 
  select(-("Timestamp")) %>%
  select(-(ends_with("comment")))
pfas <- pfas %>% 
  select(-("Timestamp")) %>% 
  select(-(ends_with("comment")))
co <- co %>% 
  select(-("Timestamp")) %>%
  select(-(ends_with("comment")))
sa <- sa %>% 
  select(-("Timestamp")) %>% 
  select(-(ends_with("comment")))
me <- me %>%
  select(-("Timestamp")) %>% 
  select(-(ends_with("comment")))
```

```{r adding tables to the dm object, include=FALSE}
data_dm_no_keys <- dm(st, sp, pfas, co, sa, me)
data_dm_no_keys
data_dm_no_keys$st
data_dm_no_keys[c("st", "co")]
```

```{r defining primary keys}
data_dm_only_pks <- data_dm_no_keys %>% 
  dm_add_pk(table = st, columns = study_ID) %>% 
  dm_add_pk(sp, species_ID) %>% 
  dm_add_pk(pfas, pfas_ID) %>% 
  dm_add_pk(co, cohort_ID) %>% 
  dm_add_pk(sa, sample_ID) %>% 
  dm_add_pk(me, measurement_ID)
data_dm_only_pks
```

```{r defining foreign keys}
data_dm_all_keys <- 
  data_dm_only_pks %>% 
  dm_add_fk(table = co, columns = study_ID, ref_table = st) %>% 
  dm_add_fk(table = co, columns = species_ID, ref_table = sp) %>%
  dm_add_fk(table = sa, columns = cohort_ID, ref_table = co) %>%
  dm_add_fk(table = me, columns = sample_ID, ref_table = sa) %>%
  dm_add_fk(table = me, columns = pfas_ID, ref_table = pfas)
data_dm_all_keys
```

```{r visualization}
data_dm_all_keys %>% 
  dm_draw()

```

```{r integrity check}
data_dm_all_keys %>% 
  dm_examine_constraints()
```

```{r merging all tables into one big table}
# dm_joined <- 
#   data_dm_all_keys %>% 
#   dm_flatten_to_tbl(.start = me, .recursive = TRUE)
# dm_joined
```

The following chunk creates a new table that merges sa, co, and me. me includes only the variables we need to calculate effect sizes (i.e., min, max, median, etc. are removed)

```{r moving columns among dm objects}
me1 <- 
  data_dm_all_keys %>% 
  dm_select(me, measurement_ID | group_info | sample_ID | pfas_ID | mean_arithmetic | SD | n | limit_type) %>% 
  dm_select(sa, sample_ID : sample_type) %>% 
  dm_select(co, cohort_ID : data_pooled) %>% 
  dm_select(pfas, pfas_ID) %>% 
  dm_select(sp, species_ID) %>% 
  dm_select(st, study_ID) %>% 
  dm_flatten_to_tbl(.start = me, .recursive = TRUE, .join = left_join)

colnames(me1)
```

Now I want to create a new column called "es_ID" which matches all the pairs of measurement I will use in the escalc() function. Study, PFAS type, species, and sampling location must be the same, so I group by them. The group (i.e., group_info) must be different

```{r}
#group by

list_dat <- 
  me1 %>% 
  dplyr::group_split(study_ID,
                  pfas_ID , 
                  species_ID,
                  sampling_location)


# TODO 

# tdat <- data.frame(me1[me1$study_ID == "S_003" & me1$pfas_ID == "pfas_001", ])
# 
# 
# adult <- tdat[tdat$group_info == "adult", 1]
# progeny <-tdat[tdat$group_info == "progeny", 1]
# 
# ids <- expand.grid(adult_id = adult, progeny_id = progeny)
# 
# adult_id <- ids[[1]]
# progeny_id <- ids[[2]]
# 
# pos_adult <- match(adult_id, tdat$measurement_ID)
# adult_dat <- tdat[pos_adult, ]
# 
# pos_progeny <- match(progeny_id, tdat$measurement_ID)
# progeny_dat <- tdat[pos_progeny, ]
# 
# #ndat<-as.data.frame(cbind(adult_dat, chick_dat))
# 
# ndat <- data.frame(measurement_ID_A = adult_dat[["measurement_ID"]],
#            measurement_ID_C = progeny_dat[[ "measurement_ID"]],
#            mean_arithmetic_A = adult_dat[["mean_arithmetic"]],
#            mean_arithmetic_C =  progeny_dat[[ "mean_arithmetic"]]
#              )

# head(ndat)

# function

wide_table <-
  function(dat)
    {

dat <-
  as.data.frame(dat)  
  
adult <-
  dat[dat$group_info == "adult", 1]
progeny <-
  dat[dat$group_info == "progeny", 1]

ids <-
  expand.grid(adult_id = adult,
              progeny_id = progeny)

adult_id <- ids[[1]]
progeny_id <- ids[[2]]

pos_adult <- match(adult_id, dat$measurement_ID)
adult_dat <- dat[pos_adult, ]

pos_progeny <- match(progeny_id, dat$measurement_ID)
progeny_dat <- dat[pos_progeny, ]

#ndat<-as.data.frame(cbind(adult_dat, chick_dat))

ndat <- data.frame(
           mean_arithmetic_A = adult_dat[["mean_arithmetic"]],
           mean_arithmetic_P =  progeny_dat[[ "mean_arithmetic"]],
           SD_A = adult_dat[["SD"]],
           SD_P = progeny_dat[["SD"]],
           n_A = adult_dat[["n"]],
           n_P = progeny_dat[["n"]],
           life_stage_A = adult_dat[["life_stage"]],
           life_stage_P = progeny_dat[["life_stage"]],
           study_ID_A = adult_dat[["study_ID"]],
           study_ID_P = progeny_dat[["study_ID"]],
           species_ID_A = adult_dat[["species_ID"]],
           species_ID_P = progeny_dat[["species_ID"]],
           sample_type_A = adult_dat[["sample_type"]],
           sample_type_P = progeny_dat[["sample_type"]],
           sampling_location_A = adult_dat[["sampling_location"]],
           sampling_location_P = progeny_dat[["sampling_location"]],
           pfas_ID_A = adult_dat[["pfas_ID"]],
           pfas_ID_P = progeny_dat[["pfas_ID"]],
           limit_type_A = adult_dat[["limit_type"]],
           limit_type_P = progeny_dat[["limit_type"]],
           sampling_year_A = adult_dat[["sampling_year"]],
           sampling_year_P = progeny_dat[["sampling_year"]],
           sampling_month_A = adult_dat[["sampling_month"]],
           sampling_month_P = progeny_dat[["sampling_month"]],
           developmental_stage_A = adult_dat[["developmental_stage"]],
           developmental_stage_P = progeny_dat[["developmental_stage"]],
           breeding_stage = adult_dat[["breeding_stage"]],
           laying_order = progeny_dat[["laying_order"]],
           nest = adult_dat[["nest"]],
           body_weight_mean = adult_dat[["body_weight_mean"]],
           body_weight_sd = adult_dat[["body_weight_sd"]],
           egg_weight_mean = progeny_dat[["egg_weight_mean"]],
           egg_weight_sd = progeny_dat[["egg_weight_sd"]],
           data_pooled = adult_dat[["data_pooled"]]
             )
ndat

}


dat <- list_dat[[3]]

res <- wide_table(list_dat[[3]])
res

# this applies wide_table data to every item in this list
ntable <- map_dfr(list_dat, wide_table)

ntable <- dplyr::mutate(ntable, es_ID = as.vector(001 : 412)) # add esID column
ntable$es_ID <-  sub("(.{1})", "es_\\1", ntable$es_ID) #add es_IDs
# ntable <- ntable[, c(27, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26)] # move es_ID column at the beginning
# the following columns are created in order to link the new ntable to the dm abject
ntable <- dplyr::mutate(ntable, study_ID =  ntable$study_ID_A) # add study_ID column
ntable <- dplyr::mutate(ntable, species_ID =  ntable$species_ID_A) # add species_ID column
ntable <- dplyr::mutate(ntable, pfas_ID =  ntable$pfas_ID_A) # add pfas_ID column

ntable <- dplyr::select(ntable, -c('study_ID_A', 'study_ID_P', 'species_ID_A', 'species_ID_P', 'pfas_ID_A', 'pfas_ID_P'))

# Remove es_IDs where limit_type_A OR limit_type_P is != NA
ntable_no_limits <- 
  ntable %>% 
  dplyr::filter(if_all(c(limit_type_A, limit_type_P), ~is.na(.)))

# Remove es_IDs where both limit_type_A AND limit_type_P are != NA
ntable <- 
  ntable %>% 
  dplyr::filter(is.na(limit_type_A) == "TRUE" |
               is.na(limit_type_P) == "TRUE")
```

Remove effect sized from pooled (male+female) data

```{r}
# ntable <-
#   ntable %>%
#   dplyr::filter(data_pooled == "No")
```

Add the ntable to the dm object

```{r adding the ntable to the dm object, include=FALSE}
nt <- ntable
data_dm_no_keys <- dm(st, sp, pfas, nt)

data_dm_only_pks <- data_dm_no_keys %>%
  dm_add_pk(table = st, columns = study_ID) %>%
  dm_add_pk(sp, species_ID) %>%
  dm_add_pk(pfas, pfas_ID) %>%
  dm_add_pk(nt, es_ID)
data_dm_only_pks

data_dm_all_keys <-
  data_dm_only_pks %>%
  dm_add_fk(table = nt, columns = study_ID, ref_table = st) %>% 
  dm_add_fk(table = nt, columns = species_ID, ref_table = sp) %>% 
  dm_add_fk(table = nt, columns = pfas_ID, ref_table = pfas)
data_dm_all_keys

data_dm_all_keys %>% 
  dm_draw()

data_dm_all_keys %>% 
  dm_examine_constraints()
```

# Functions

The `lnRR_func` function is here used to calculate a log response ratio (lnRR) adjusted for small sample sizes. In addition, this formula accounts for correlated samples. For more details, see *Doncaster and Spake (2018) Correction for bias in meta-analysis of little-replicated studies. Methods in Ecology and Evolution; 9:634-644*

```{r function to calculate effect size}
#Changing columns names to make them shorter
colnames(nt)[1] <- "mean_A"
colnames(nt)[2] <- "mean_P"
colnames(nt)[3] <- "sd_A"
colnames(nt)[4] <- "sd_P"

# Custom function to calculate the lnRR 
lnRR_func <- function(mean_A, n_A, mean_P, n_P, aCV2a, aCV2p){
  lnRR <- log(mean_P/mean_A) + 
        0.5 * ((aCV2p/n_P) - (aCV2a/n_A))	
  lnRR
}
# Custom function to calculate the lnRR's sampling variance from independent designs (rTC = 0)
var_lnRR_ind <- function(mean_A, n_A, mean_P, n_P, aCV2a, aCV2p){
  
  var_lnRR <- (aCV2a/n_A) + (aCV2p/n_P) 
  
  var_lnRR
}
# Mc: Concentration of PFAS of the raw (control) sample
# Nc: Sample size of the raw (control) sample
# Me: Concentration of PFAS of the cooked (experimental) sample
# Ne: Sample size of the cooked (experimental) sample 
# aCV2c: Mean coefficient of variation of the raw (control) samples
# aCV2e: Mean coefficient of variation of the cooked (experimental) samples

```

# Phylogenetic information

Import phylogenetic information and calculate phylogenetic variance-covariance matrix

NOTE: The phylogenetic tree was generated in the `tree_MA_MT_PFAS.Rmd` document

```{r, fig.height=10, fig.width = 8}
tree <- read.tree(here("R", "phylogenetic_tree.tre")) # Import phylogenetic tree (see tree_MA_MT_PFAS.Rmd for more details) 
tree <- compute.brlen(tree) # Generate branch lengths 
cor_tree <- vcv(tree,corr = T) # Generate phylogenetic variance-covariance matrix 

nt2 <- 
  data_dm_all_keys %>% 
  dm_select(sp, species_ID | species_scientific_name) %>% 
  dm_flatten_to_tbl(nt, sp, .join = left_join)

nt2$Phylogeny <- as.factor(str_replace(nt2$species_scientific_name, " ", "_")) # Add the `phylogeny` column to the data frame
colnames(cor_tree) %in% nt2$Phylogeny # Check correspondence between tip names and data frame

# Rename species names that do not match
levels(nt2$Phylogeny)[levels(nt2$Phylogeny) == "Larus_audouinii"] <- "Ichthyaetus_audouinii"
levels(nt2$Phylogeny)[levels(nt2$Phylogeny) == "Phalacrocorax_aristotelis"] <- "Gulosus_aristotelis"
levels(nt2$Phylogeny)[levels(nt2$Phylogeny) == "Diomedea_immutabilis"] <- "Phoebastria_immutabilis"

# checking all species are in the data
match(unique(nt2$Phylogeny),colnames(cor_tree))
match(nt2$Phylogeny, colnames(cor_tree))
# plotting tree
plot(tree)
```

# Effect sizes

Calculate effect sizes

```{r Calculating lnRR and Variance}
# Calculate the squared coefficient of variation for adult and progeny groups

colnames(nt2)[1] <- "mean_A"
colnames(nt2)[2] <- "mean_P"
colnames(nt2)[3] <- "sd_A"
colnames(nt2)[4] <- "sd_P"

aCV2 <- nt2 %>% 
  group_by(study_ID) %>%
  summarise(CV2a = mean((sd_A/mean_A)^2, na.rm = T),
            CV2p = mean((sd_P/mean_P)^2, na.rm = T)) %>% 
  ungroup() %>% # ungroup 
  summarise(aCV2a = mean(CV2a, na.rm = T), # Mean CV^2 for exp and control groups across studies 
            aCV2p = mean(CV2p, na.rm = T))

lnRR <- lnRR_func(mean_A = nt2$mean_A,
                  n_A = nt2$n_A,
                  mean_P = nt2$mean_P,
                  n_P = nt2$n_P,
                  aCV2a = aCV2[[1]],
                  aCV2p = aCV2[[2]])

var_lnRR <- var_lnRR_ind(mean_A = nt2$mean_A,
                  n_A = nt2$n_A,
                  mean_P = nt2$mean_P,
                  n_P = nt2$n_P,
                  aCV2a = aCV2[[1]],
                  aCV2p = aCV2[[2]]) 

dat <- nt2 %>% 
  dplyr::mutate(N_tilde = (n_A*n_P)/(n_A + n_P)) # getting effective sample size

dat <- cbind(dat, lnRR, var_lnRR) # Merge effect sizes with the data frame
```

## Distribution of effect sizes

```{r, fig.height=8, fig.width=15}
# mean 
ggplot(dat, aes(x=lnRR))+ geom_histogram(fill = "salmon", col = "black", binwidth = 0.2) + theme_classic()
# variance
ggplot(dat, aes(x=var_lnRR))+ geom_histogram(fill = "salmon", col = "black", binwidth = 0.05) + theme_classic()
# log variance
ggplot(dat, aes(x=var_lnRR))+ geom_histogram(fill = "salmon", col = "black", binwidth = 0.05) + scale_x_log10()+theme_classic()
```

```{r create the forest plot}
forest(dat$lnRR, dat$var_lnRR)
```

## Table of sample sizes

```{r}
table_sample_sizes <- dat %>% 
  dplyr::summarise('studies' = n_distinct(study_ID),
                   'species' = n_distinct(Phylogeny),
                   'pfas type' = n_distinct(pfas_ID),
                   'effect sizes' = n_distinct(es_ID),
                   'effect sizes (eggs)' = n_distinct(es_ID[life_stage_P == "egg"]),
                   'studies (eggs)' = n_distinct(study_ID[life_stage_P == "egg"]),
                   'species (eggs)' = n_distinct(Phylogeny[life_stage_P == "egg"]),
                   'effect sizes (chicks)' = n_distinct(es_ID[life_stage_P == "chick"]),
                   'studies (chicks)' = n_distinct(study_ID[life_stage_P == "chick"]),
                   'species (chicks)' = n_distinct(Phylogeny[life_stage_P == "chick"])
                   )

table_sample_sizes<-t(table_sample_sizes)

colnames(table_sample_sizes)<-"n (sample size)"

kable(table_sample_sizes) %>% 
  kable_styling("striped", position="left")
```

# Summary of the dataset

```{r}
kable(summary(dat), "html") %>% 
  kable_styling("striped", position = "left") %>% 
    scroll_box(width = "100%", height = "500px")
```

# Meta-analysis {.tabset}

...

## Intercept meta-analytical model

Now that we calculated the effect size measures, we fit an intercept only, meta-analytic model

read <https://daniel1noble.github.io/orchaRd/> for more details on making pretty plots.

```{r}
m1 <- rma.mv(yi = lnRR,
             V = var_lnRR,
             random = list(~1|es_ID,
                           ~1|study_ID),
             test = "t",
             data = filter(dat,
                               is.na(mean_A)=="FALSE" & 
                                 is.na(mean_P)=="FALSE")) # remove NA in means
summary(m1) 
i2_ml(m1)
```

##Table of results and orchard and caterpillar plot.

```{r}
model_results <- 
  mod_results(m1, 
              mod = "1",
              at = NULL, 
              data = filter(dat, 
                                    is.na(mean_A)=="FALSE" &
                                      is.na(mean_P)=="FALSE"), 
              group = "study_ID")
model_results

orchaRd::orchard_plot(m1,
                      mod = "1", 
                      data = filter(dat, 
                                    is.na(mean_A)=="FALSE" &
                                      is.na(mean_P)=="FALSE"), 
                      group = "study_ID",
                      xlab = "lnRR", 
                      alpha=0.4)
```

Use i2_sn function to obtain the total I\^2

```{r}
I2 <- orchaRd::i2_ml(m1)

orchaRd::orchard_plot(model_results, mod="1", xlab = "lnRR") + 
  annotate(geom="text", x= 0.80, y= 1, label= paste0("italic(I)^{2} == ", round(I2[1],4)), # I want to use % but cannot do should come back
              color="black", parse = TRUE, size = 5) +
  scale_fill_manual(values="grey") +
  scale_colour_manual(values="grey")
```

From prevouos graphs we can see that overall estimate from a random-effects meta-analysis of 371 effect sizes is centered on zero, with a 95% CI that spans the line of no-effect. The prediction intervals clearly demonstrate the high level of heterogeneity (over 95%).

We can now draw a comparable caterpillar plot by using the function caterpillars.

```{r}
orchaRd::caterpillars(model_results, mod="Int", xlab = "lnRR") 
```

## Meta-regression model

###Bird species
Now, we want to fit a meta-regression model to test whether the moderator "species_ID" impacts our results on the mean and variance.

```{r}
mr1 <- rma.mv(lnRR, 
              var_lnRR,
              mods = ~ species_ID,
              random = list(~1|es_ID,
                           ~1|study_ID),
              test = "t",
              data = filter(dat,
                               is.na(mean_A)=="FALSE" & 
                                 is.na(mean_P)=="FALSE"))
summary(mr1)
```
Again, we can create a table of results and draw plots
```{r}
res2 <- orchaRd::mod_results(mr1, 
                             mod = "species_ID",
                             data = filter(dat,
                               is.na(mean_A)=="FALSE" & 
                                 is.na(mean_P)=="FALSE"),
                             group = "study_ID",
                             )
res2

p1 <- orchaRd::orchard_plot(res2,
                            mod = "species_ID",
                            data = filter(dat,
                               is.na(mean_A)=="FALSE" & 
                                 is.na(mean_P)=="FALSE"),
                            group = "study_ID",
                            xlab = "log(Response ratio) (lnRR)",
                            angle = 45,
                            g = "FALSE"
                             )
p1

orchaRd::caterpillars(res2, mod="Int", xlab = "lnRR") 
```

###PFAS type
```{r}
mr2 <- rma.mv(lnRR, 
              var_lnRR,
              mods = ~ pfas_ID,
              random = list(~1|es_ID,
                           ~1|study_ID),
              test = "t",
              data = filter(dat,
                               is.na(mean_A)=="FALSE" & 
                                 is.na(mean_P)=="FALSE"))
summary(mr1)

res3 <- orchaRd::mod_results(mr2, 
                             mod = "pfas_ID",
                             data = filter(dat,
                               is.na(mean_A)=="FALSE" & 
                                 is.na(mean_P)=="FALSE"),
                             group = "study_ID",
                             )
res3

number <- nlevels(dat$pfas_ID)

p2 <- orchaRd::orchard_plot(res3,
                            mod = "pfas_ID",
                            data = filter(dat,
                               is.na(mean_A)=="FALSE" & 
                                 is.na(mean_P)=="FALSE"),
                            group = "study_ID",
                            xlab = "log(Response ratio) (lnRR)",
                            angle = 45
                             )
p2

orchaRd::caterpillars(res3, mod="Int", xlab = "lnRR")
```
























### Determine the random effect structure

```{r}
MA_all_rand_effects <- rma.mv(lnRR, var_lnRR, # Add `var_lnRR` to account for correlated errors between cohorts (shared_controls)
              random = list(~1|study_ID, # Identity of the study
                            ~1|Phylogeny, # Phylogenetic correlation between species
                            ~1|pfas_ID, # Type of PFAS 
                            ~1|es_ID, # Effect size identity 
                            ~1|sample_type_A,
                            ~1|sample_type_P), 
              R = list(Phylogeny = cor_tree),
              test = "t", 
              data = dat,
              sparse = TRUE)
summary(MA_all_rand_effects) # Phylogeny does not explain for any variance
```
